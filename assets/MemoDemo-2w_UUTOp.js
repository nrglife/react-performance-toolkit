import{j as e,l as m,g as n,p,r as j,h as a,o as c,i as d,z as D,H as P,v as B,R as N,F as k,u as M,D as w,s as y}from"./mui-vendor-BcogAy2T.js";import{r as o}from"./react-vendor-bYt7__KG.js";import{D as O,C}from"./CodeBlock-DwP4a17t.js";import{a as z}from"./expensiveCalculation-CrE_IYLs.js";import"./index-C8ZS78_l.js";import"./tanstack-query-qmwwa--H.js";function g({label:i}){const s=o.useMemo(()=>({count:0}),[]);return s.count++,e.jsx(y,{label:`${i}: ${s.count} renders`,size:"small",color:s.count>5?"error":s.count>2?"warning":"success",sx:{fontFamily:"monospace"}})}function H({onClick:i,message:s}){const t=o.useMemo(()=>({value:s}),[]),l=t.value!==s;return t.value=s,e.jsx(p,{variant:"outlined",sx:{height:"100%"},children:e.jsxs(j,{children:[e.jsxs(a,{sx:{display:"flex",justifyContent:"space-between",alignItems:"center",mb:2},children:[e.jsx(n,{variant:"h6",children:"Unmemoized Child"}),e.jsx(g,{label:"Child"})]}),e.jsx(n,{variant:"body2",color:"text.secondary",sx:{mb:2},children:"This component re-renders every time the parent re-renders, even when its props haven't changed."}),e.jsxs(a,{sx:{mb:2,p:1,bgcolor:"background.default",borderRadius:1},children:[e.jsxs(n,{variant:"caption",color:"text.secondary",display:"block",sx:{mb:.5},children:["Props changed?"," ",e.jsx(y,{label:l?"YES":"NO",size:"small",color:l?"error":"success",sx:{ml:1}})]}),e.jsxs(n,{variant:"caption",color:"text.secondary",children:["Message: ",e.jsx("strong",{children:s})]})]}),e.jsx(d,{variant:"outlined",onClick:i,fullWidth:!0,children:"Click Me"})]})})}const V=o.memo(function({onClick:s,message:t}){const l=o.useMemo(()=>({value:t}),[]),h=l.value!==t;return l.value=t,e.jsx(p,{variant:"outlined",sx:{height:"100%"},children:e.jsxs(j,{children:[e.jsxs(a,{sx:{display:"flex",justifyContent:"space-between",alignItems:"center",mb:2},children:[e.jsx(n,{variant:"h6",children:"Memoized Child"}),e.jsx(g,{label:"Child"})]}),e.jsx(n,{variant:"body2",color:"text.secondary",sx:{mb:2},children:"This component only re-renders when its props actually change (thanks to React.memo)."}),e.jsxs(a,{sx:{mb:2,p:1,bgcolor:"background.default",borderRadius:1},children:[e.jsxs(n,{variant:"caption",color:"text.secondary",display:"block",sx:{mb:.5},children:["Props changed?"," ",e.jsx(y,{label:h?"YES":"NO",size:"small",color:h?"error":"success",sx:{ml:1}})]}),e.jsxs(n,{variant:"caption",color:"text.secondary",children:["Message: ",e.jsx("strong",{children:t})]})]}),e.jsx(d,{variant:"outlined",onClick:s,fullWidth:!0,children:"Click Me"})]})})});function Y({count:i,useMemoization:s}){const t=o.useMemo(()=>({count:0}),[]),l=o.useMemo(()=>(t.count++,z(i)),[i]),h=s?0:(t.count++,z(i)),b=s?l:h;return e.jsx(p,{variant:"outlined",children:e.jsxs(j,{children:[e.jsxs(a,{sx:{display:"flex",justifyContent:"space-between",alignItems:"center",mb:2},children:[e.jsx(n,{variant:"h6",children:"Expensive Calculation"}),e.jsx(g,{label:"Component"})]}),e.jsx(n,{variant:"body2",color:"text.secondary",sx:{mb:2},children:s?"Using useMemo: Calculation only runs when count changes":"Without useMemo: Calculation runs on every render"}),e.jsxs(a,{sx:{mb:2,p:1,bgcolor:"background.default",borderRadius:1},children:[e.jsxs(n,{variant:"caption",color:"text.secondary",display:"block",sx:{mb:.5},children:["Calculation runs:"," ",e.jsx(y,{label:`${t.count} times`,size:"small",color:t.count>3?"error":t.count>1?"warning":"success",sx:{ml:1,fontFamily:"monospace"}})]}),e.jsxs(n,{variant:"caption",color:"text.secondary",children:["Result: ",e.jsx("strong",{children:b.toFixed(4)})]})]})]})})}function Z(){const[i,s]=o.useState(0),[t,l]=o.useState(""),[h,b]=o.useState(0),[v,f]=o.useState("Hello"),[x,R]=o.useState(!0),[u,W]=o.useState(!0),[S,T]=o.useState(0),U=o.useCallback(()=>{console.log("Stable callback called")},[]),I=()=>{console.log("Unstable callback called")},E=()=>{s(0),l(""),b(0),f("Hello"),T(r=>r+1)},F=()=>{f(r=>r==="Hello"?"World":"Hello")};return e.jsxs(O,{title:"Memoization Demo",description:"Understand what causes re-renders and how React.memo, useCallback, and useMemo prevent unnecessary work",children:[e.jsxs(m,{severity:"info",sx:{mb:3},children:[e.jsx(n,{variant:"body2",sx:{fontWeight:"bold",mb:1},children:"üéØ Try This: Interact with the controls below"}),e.jsx(n,{variant:"body2",children:"Watch the render counters to see which components re-render. Toggle memoization on/off to see the difference!"})]}),e.jsx(p,{sx:{mb:3,bgcolor:"action.hover"},children:e.jsxs(j,{children:[e.jsxs(a,{sx:{display:"flex",justifyContent:"space-between",alignItems:"center",mb:3},children:[e.jsx(n,{variant:"h6",children:"Parent Component"}),e.jsx(g,{label:"Parent"})]}),e.jsxs(c,{container:!0,spacing:2,sx:{mb:3},children:[e.jsxs(c,{size:{xs:12,md:6},children:[e.jsxs(a,{sx:{display:"flex",gap:1,alignItems:"center"},children:[e.jsx(d,{variant:"contained",startIcon:e.jsx(D,{}),onClick:()=>s(r=>r-1),children:"Decrement"}),e.jsx(n,{variant:"h6",sx:{minWidth:60,textAlign:"center"},children:i}),e.jsx(d,{variant:"contained",startIcon:e.jsx(P,{}),onClick:()=>s(r=>r+1),children:"Increment"})]}),e.jsx(n,{variant:"caption",color:"text.secondary",sx:{mt:1,display:"block"},children:"Changes count state (affects expensive calculation)"})]}),e.jsxs(c,{size:{xs:12,md:6},children:[e.jsx(B,{fullWidth:!0,label:"Text Input",value:t,onChange:r=>l(r.target.value),placeholder:"Type something...",size:"small"}),e.jsx(n,{variant:"caption",color:"text.secondary",sx:{mt:1,display:"block"},children:"Changes text state (unrelated to children)"})]}),e.jsxs(c,{size:{xs:12,md:6},children:[e.jsxs(d,{variant:"outlined",startIcon:e.jsx(N,{}),onClick:()=>b(r=>r+1),fullWidth:!0,children:["Trigger Unrelated Re-render (",h,")"]}),e.jsx(n,{variant:"caption",color:"text.secondary",sx:{mt:1,display:"block"},children:"Changes state that doesn't affect any child props"})]}),e.jsxs(c,{size:{xs:12,md:6},children:[e.jsxs(d,{variant:"contained",color:"secondary",onClick:F,fullWidth:!0,children:['Change Child Message: "',v,'"']}),e.jsx(n,{variant:"caption",color:"text.secondary",sx:{mt:1,display:"block"},children:"Changes the message prop passed to child"})]})]}),e.jsxs(a,{sx:{display:"flex",gap:2,flexWrap:"wrap"},children:[e.jsx(k,{control:e.jsx(M,{checked:u,onChange:r=>W(r.target.checked)}),label:e.jsx(a,{sx:{display:"flex",alignItems:"center",gap:1},children:e.jsx(n,{variant:"body2",children:u?"‚úÖ React.memo + useCallback":"‚ùå No Memoization"})})}),e.jsx(k,{control:e.jsx(M,{checked:x,onChange:r=>R(r.target.checked)}),label:e.jsx(a,{sx:{display:"flex",alignItems:"center",gap:1},children:e.jsx(n,{variant:"body2",children:x?"‚úÖ useMemo ON":"‚ùå useMemo OFF"})})}),e.jsx(d,{variant:"text",onClick:E,size:"small",children:"Reset Counters"})]})]})},S),e.jsxs(c,{container:!0,spacing:2,sx:{mb:3},children:[e.jsx(c,{size:{xs:12,md:6},children:u?e.jsx(V,{onClick:U,message:v}):e.jsx(H,{onClick:I,message:v})}),e.jsx(c,{size:{xs:12,md:6},children:e.jsx(Y,{count:i,useMemoization:x})})]}),e.jsxs(m,{severity:u?"success":"warning",sx:{mb:3},children:[e.jsx(n,{variant:"body2",sx:{fontWeight:"bold",mb:1},children:u?"‚úÖ With Memoization:":"‚ùå Without Memoization:"}),u?e.jsxs(e.Fragment,{children:[e.jsxs(n,{variant:"body2",sx:{mb:1},children:["‚Ä¢ ",e.jsx("strong",{children:"Child component"})," only re-renders when its props actually change"]}),e.jsx(n,{variant:"body2",sx:{mb:1},children:`‚Ä¢ Try typing in text field or "Trigger Unrelated Re-render" - child doesn't re-render`}),e.jsx(n,{variant:"body2",sx:{mb:1},children:'‚Ä¢ Click "Change Child Message" - child DOES re-render (props actually changed!)'}),e.jsx(n,{variant:"body2",children:'‚Ä¢ Notice: "Props changed?" shows NO for unrelated changes, YES when message changes'})]}):e.jsxs(e.Fragment,{children:[e.jsxs(n,{variant:"body2",sx:{mb:1},children:["‚Ä¢ ",e.jsx("strong",{children:"Child component"})," re-renders every time the parent re-renders"]}),e.jsx(n,{variant:"body2",sx:{mb:1},children:'‚Ä¢ Try typing in text field or "Trigger Unrelated Re-render" - child re-renders unnecessarily'}),e.jsx(n,{variant:"body2",children:'‚Ä¢ Notice: "Props changed?" shows YES every time (new callback = new reference)'})]})]}),e.jsxs(m,{severity:x?"success":"warning",sx:{mb:3},children:[e.jsx(n,{variant:"body2",sx:{fontWeight:"bold",mb:1},children:x?"‚úÖ With useMemo:":"‚ùå Without useMemo:"}),x?e.jsxs(e.Fragment,{children:[e.jsxs(n,{variant:"body2",sx:{mb:1},children:["‚Ä¢ ",e.jsx("strong",{children:"Expensive calculation"})," only runs when count changes"]}),e.jsx(n,{variant:"body2",sx:{mb:1},children:'‚Ä¢ Try typing in text field - "Calculation runs" counter stays the same'}),e.jsx(n,{variant:"body2",children:"‚Ä¢ Click increment/decrement - counter increases (count changed, so calculation re-runs)"})]}):e.jsxs(e.Fragment,{children:[e.jsxs(n,{variant:"body2",sx:{mb:1},children:["‚Ä¢ ",e.jsx("strong",{children:"Expensive calculation"})," runs on every render"]}),e.jsx(n,{variant:"body2",sx:{mb:1},children:'‚Ä¢ Try typing in text field - "Calculation runs" counter increases unnecessarily'}),e.jsx(n,{variant:"body2",children:"‚Ä¢ Watch the counter grow even though count hasn't changed!"})]})]}),e.jsxs(m,{severity:"info",sx:{mb:3},children:[e.jsx(n,{variant:"body2",sx:{fontWeight:"bold",mb:1},children:"‚ÑπÔ∏è Why do counters start at 2?"}),e.jsxs(n,{variant:"body2",children:["React's Strict Mode (enabled in development) intentionally renders components twice to help detect bugs. In production builds, everything runs once. The key insight is the ",e.jsx("strong",{children:"difference"})," between memoized and unmemoized behavior, not the absolute numbers."]})]}),e.jsx(w,{sx:{my:4}}),e.jsxs(a,{children:[e.jsx(n,{variant:"h6",gutterBottom:!0,children:"Implementation"}),e.jsx(C,{title:"React.memo - Prevent Unnecessary Re-renders",code:`import { memo } from 'react';

// Without React.memo - re-renders on every parent render
function UnmemoizedChild({ onClick }) {
  return <button onClick={onClick}>Click Me</button>;
}

// With React.memo - only re-renders when props change
const MemoizedChild = memo(function MemoizedChild({ onClick }) {
  return <button onClick={onClick}>Click Me</button>;
});`,language:"typescript"}),e.jsx(C,{title:"useCallback - Stable Function References",code:`import { useCallback } from 'react';

function Parent() {
  // ‚ùå New function on every render
  const unstableCallback = () => {
    console.log('Called');
  };

  // ‚úÖ Stable function reference
  const stableCallback = useCallback(() => {
    console.log('Called');
  }, []); // Empty deps = never changes

  return <MemoizedChild onClick={stableCallback} />;
}`,language:"typescript"}),e.jsx(C,{title:"useMemo - Cache Expensive Calculations",code:`import { useMemo } from 'react';

function Component({ count }) {
  // ‚ùå Runs on every render
  const result = expensiveCalculation(count);

  // ‚úÖ Only runs when count changes
  const memoizedResult = useMemo(() => {
    return expensiveCalculation(count);
  }, [count]);

  return <div>{memoizedResult}</div>;
}`,language:"typescript"})]}),e.jsx(w,{sx:{my:4}}),e.jsxs(a,{children:[e.jsx(n,{variant:"h6",gutterBottom:!0,children:"When to Use Memoization"}),e.jsxs(m,{severity:"warning",sx:{mb:2},children:[e.jsx(n,{variant:"body2",sx:{fontWeight:"bold",mb:1},children:"‚ö†Ô∏è Don't Memoize Everything!"}),e.jsx(n,{variant:"body2",children:"Memoization has overhead. Only use it when you have measurable performance issues or expensive operations."})]}),e.jsx(n,{variant:"subtitle2",gutterBottom:!0,sx:{mt:2},children:"Use React.memo when:"}),e.jsx(n,{variant:"body2",color:"text.secondary",sx:{mb:1},children:"‚Ä¢ Component re-renders often with the same props"}),e.jsx(n,{variant:"body2",color:"text.secondary",sx:{mb:2},children:"‚Ä¢ Component is expensive to render (complex UI, many children)"}),e.jsx(n,{variant:"subtitle2",gutterBottom:!0,children:"Use useCallback when:"}),e.jsx(n,{variant:"body2",color:"text.secondary",sx:{mb:1},children:"‚Ä¢ Passing callbacks to memoized child components"}),e.jsx(n,{variant:"body2",color:"text.secondary",sx:{mb:2},children:"‚Ä¢ Callback is used as a dependency in useEffect or useMemo"}),e.jsx(n,{variant:"subtitle2",gutterBottom:!0,children:"Use useMemo when:"}),e.jsx(n,{variant:"body2",color:"text.secondary",sx:{mb:1},children:"‚Ä¢ Calculation is genuinely expensive (loops, sorting, filtering large arrays)"}),e.jsx(n,{variant:"body2",color:"text.secondary",sx:{mb:1},children:"‚Ä¢ Creating objects/arrays that are used as dependencies"}),e.jsx(n,{variant:"body2",color:"text.secondary",children:"‚Ä¢ Value is passed to memoized components as a prop"})]})]})}export{Z as default};
